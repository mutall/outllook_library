<?php

namespace mutall;
//
//Resolve the reference to the database
include_once 'schema.php';

//Report errors 
class component {
    //
    //The directory where the crontab executing file is contained
    const home = "/home/mutall/projects/schema/v/";
    //
    //The the crontab file for compiling crontab entries
    const crontab_file = "mutalldata_crontab.txt";
    //
    //The crontab command with the file for refreshing a crontab file
    const crontab_command = "schedule_crontab.php";
    //
    //The user creating and executing the crontab
    const user = "www-data ";
    //
    //The log file for logging the errors generated by the user
    const log_file = "log.txt";
    //
    //The errors collected by this component (for logging)
    public array $errors = [];
    //
    //The database used for managing scheduling
    const mutall_users = "mutall_users";
    //
    //the class constructor
    function _construct() {
        //
        //Create a connection to the database, without initializing it with 
        //entities
        $this->dbase = new database(component::mutall_users, false);
    }
    //
    //The error reporting function
    public function report_errors(array $errors/*:string*/) {
        //
        //1. Compile the errors into a single message.
        foreach ($errors as $error) {
            //
            //The path to the error log file
            $error_file = __DIR__."/".self::log_file;
            //
            //Open the cron error file.
            //NOTE: Fopen also creates the file incase it is absent
            $file = fopen($error_file, "w");
            //
            //Compile the errors to add to the file
            $result = "$error \n";
            //
            //Add the errors into the error file
            fwrite($file, $result);
            //
            //Close the file
            fclose($file);
        }
        //
        //2. Save the error into the msg table.
        //
        //2.1 Compile the errors generated
        $result = implode("\n", $errors);
        //
        //2.2 Develop the query to execute
        $query = $this->dbase->chk(
            "INSERT INTO msg "
                . "(subject, text) "
                . "VALUES('Error:-','$result')"
        );
        //
        //2.3 Execute the query to update the results
        $this->dbase->query($query);
    }
        
}
//
//The scheduler is responsible for creating jobs that execute once or multiple
//times, i..e, repetitively
abstract class scheduler extends component {
    //
    //The user database used for manging the scehduling
    public database $dbase;
    //
    function __construct() {
        //
        //Open teh named database
        $this->dbase = new database(component::user);
    }
    
    //Returns teh sql associated this scheduler
    abstract function get_sql():string;
    //
    //Run the given entries on a linux platform. Crontab entries cannot be run 
    //directly; they have to be packed in a crontab file
    abstract function run(array $entries):void;
    //
    //Rebuilds a fresh plan on a linux server that suuports the 'at' and 
    //'crontab' commands
    function refresh():void{
        //
        //Prepare to catch and log any errors for logging
        try{
            //
            //Clear the current plan running on the server. This is necessary for
            //the 'at' command; it not for crontab
            $this->clear_commands();
            //
            //Formulate the sql for retrieving all active entries
            $sql = $this->get_sql();
            //
            //Execute the sql to retrieve the (static) entries
            $fuels = $this->dbase->get_sql_data($sql);
            //
            //Activate the entries
            $entries = array_map(fn($fuel)=>entry::create($fuel), $fuels);
            //
            //Run the entries on the linux server
            $this->run($entries);
        }catch(\Exception $ex){
            //
            //Compile the full message, including the trace
             //
            //Replace the hash with a line break in the trace message
            $trace = \str_replace("#", PHP_EOL, $ex->getTraceAsString());
            //
            //Record the error message in a friendly way
            $output = $ex->getMessage() . PHP_EOL . $trace;
            //
            //Log the exception that may have occured during this process. This 
            //reporting is special in that a user is not available when the 
            //refresh is happening, as this is part of a script
            report_errors([$output]);
        }
    }
    
    //Clear the current plan running on the server. This is necessary for
    //the 'at' command; it not for crontab
    function clear_commands(){}
            
}


class at_scheduler extends scheduler{
    //
    function __construct(){
        parent::__construct();
    }
    //
    function get_sql():string{
        //
        //Read the at command entries from an external file
        return file_get_contents(__DIR__.'/get_at_entries.php');
    }
    
    //The entries of at at command are execited directly
    function run(array $entries):void{
        //
        foreach($entries as $entry){
            //
            //The result of successfuly running an at command is a string
            //that shows the id number assigned to the job. Otherwise it is
            //an error
            $result /*:string*/=$entry->execute();
            //
            //Analyse the resulting string. If not successful, log the error
            if ($this->failed($result)) $this->errors[]=$result;
        }
    }
    
    //Clear the current plan running on the server. This is necessary for
    //the 'at' command; it is not for crontab
    function clear_commands(){
        //
        //Clear the at queue before loading the new batch of at jobs
        //
        //The 'cut' is a linux method that takes its inputs as tabular data and
        //returns the entries in column 1 (-f1 option). atqproduces teh tabular 
        //data as a list of all ruuning at jobs. The first column has teh job ids
        //The ids are then supplied as arguments to the at remove (atrm) method
        //in the stye of a foreach statement. Note the $() construct that does this
        //magic 
        mutall::shell_exec("atrm $(atq | cut -f1)");
    }
}

//A component for scehduling repetitive activities
class crontab_scheduler{
    
    function __construct(){}
    
    //Returns the sql for retrieving entries of a cronjob
    function get_sql():string{
        //
         return  
            'select 
                command, 
                frequency 
            from 
                activity 
            where
                start_date<now() and end_date>=now()';
    }
    
    //The entries of a crontab are not eecuted directly. They are compiled into
    //a cronfile that is then executed -- nullifying all the activities
    //that were previously running and with new ones
    function run(array $entries):void {
        //
        //Map all the entries to the entries to thier text equivalents
        $texts = array_map(fn($entry)=>"$entry", $entries);
        //
        //Join them with a new line separator\
        $job = join(PHP_EOL, $texts);
        //
        //Formulate the crontab file name;
        $filename = __DIR__."/".component::crontab_file;
        //
        //Create a cron file that contains all crontab entries.
        file_put_contents($filename, $job);
        //
        //Modify the file permissions. Throw exception if this fails
        if (!chmod($filename, 0777))
            throw new \Exception("This chmod failed for file '$filename'");
        //
        //execute teh cron file
        $result /*:true|string*/= $this->execute($filename);
        //
        //Collect the error if the exceution failed 
        if ($result!==true) $this->errors[]= $result;
    }
    
    //A crontab scheduler can be exceuted as a single file
    function execute(string $filename):true|string{
        //
        //Compile the cronjob. 
        //NOTE:- The php user is identified by www-data
        //and a user needs permissions to set up a crontab otherwise it wont execute
        $command = "crontab -u" . component::user . " ". $filename;
        //  
        //Run the cron job
        $result = mutall::shell_exec($command);
        //
        //If the crontab command executed successfully, return
        return (is_null($result)) ? true: $result;
    }
}

//
//A crontab or at command entry
class entry{
    //
    //The linux command to be executed by this entry
    public string $command;
    function __construct(string /*:linux_command*/ $cmd){
        $this->command = $cmd;
    }

    //Creating an at or crontab entry
    static function create(array $fuel):entry{
        //
        //If fuel has a frequency, then this is a crontab entry. 
        if (key_exists('frequency', $fuel)){
            return new crontab_scheduler($fuel['command'], $fuel['frequency']);
        }
        //Otherwise it is an at entry
        else{
            return new at_entry($fuel['command'], $fuel['date']);
        }    
    }
}

class at_entry extends entry{
    //
    //Date of executing this activity
    public string $date;
    //
    function __construct(string /*:linux_command*/ $cmd, string $date){
        parent::__construct($cmd);
        //
        $this->date = $date;
    }
    //
    //An 'at' entty can be executed
    function execute():string{
        //
        //The date when the at command should run
        $date = $this->date;
        //
        //Construct the log file
        $log =__DIR__."/".component::log_file;
        //
        //We assume that the user specified command is as complete as possible
        //so that, if a php file needs to be exceuted, the programmer is
        //repossible for specifying its path. If the origin of the job is a
        //user form, the programmer should make the specification of a
        //php file locaton as less painful as possible
        $command = "echo $this->command >> $log | at $date";
        //
        //Run an at command non-interactively.
        $result = mutall::shell_exec($command);
        //
        //For an at command, if  successful, a user may recevive a message 
        //to the effect that the at command is running with an assigned id.
        //Study the message to chack cases where the at cpmmand may fave failed
        return $result;
    }
}

//A cron entry (unlike that of an 'at') cannot be exceuted
class crontab_entry extends entry{
    //
    //Repetition frequency specified in crontab style
    public $frequency;
    //        
    function __construct(string /*:linux_command*/ $cmd, string $frequency){
        parent::__construct($cmd);
        $this->frequency = $frequency;
    }
    
    //The string version of a crontab entry
    function __toString(){
        //
        //Compile the user
        $user = component::user;
        //
        //The log file
        $log = __DIR__."/". component::log_file;
        //
        //The crontab entry for sending messages
        $entry = "$this->frequency -u $user $this->command >> $log";
        //
        return $entry;
    }
}
